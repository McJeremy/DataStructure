#堆
在计算机科学中，堆（Heap）是一种基于树（Tree）的特殊的数据结构。堆需要满足堆特性（Heap Property）：如果节点 A 是节点 B 的父节点，则节点 A 中的键值与节点 B 中的键值的比较顺序关系将适用于堆中的所有节点。也就是可以总结为两种情况:  
1. 父节点的键值大于等于子节点的键值 A(Parent(i)) ≥ A[i] ，则根节点的键值为堆中的最大值。这种类型的堆叫做最大堆（Max Heap）。  
2. 父节点的键值小于等于子节点的键值 A(Parent(i)) ≤ A[i]，则根节点的键值为堆中的最小值。这种类型的堆叫做最小堆（Min Heap）。

由于堆中的最大值或最小值总是被存储在根节点（Root Node）中，所以名字称为堆。堆不是一种排序的数据结构，可认为是部分排序的结构。从堆的图形结构来看，在相同层级中的节点间没有任何特定的关系，即使是兄弟节点。

堆经常被应用于优先队列（Priority Queue），当你需要找到队列中最高优先级或者最低优先级的元素时，使用堆结构可以帮助你快速的定位元素。

##二叉堆
其实际上是一颗二叉树（Binary Tree），并且是一颗完全二叉树（Complete Binary Tree）。如下图中展示了一个完全二叉的最大堆。

当堆被实现为完全二叉树时，其高度为最小高度。如果堆中有 n 个节点，则最小高度为 Θ(lg n)。

实现堆结构时通常使用数组结构（Array），并且元素间不需要指针引用。使用完全二叉树或者满二叉树实现堆时可以保持最优的空间效率。通常第一个元素或最后一个元素将保存根节点，根节点后紧跟着其两个子节点，两个子节点后将紧跟着 4 个这两个子节点的子节点，以此类推。因此，在一个以 0 为起点的数组中，位置 i 处的节点的子节点的位置将位于 2i+1 和 2i+2 处。平衡一个堆的操作将使用元素互换的方式，所以对堆进行排序无需使用额外的空间，堆排序（heapsort）即是用了这种就地排序（In-Place）的方式。

##堆排序

堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。二叉堆数据结构是一种数组对象，它可以被视为一棵完全二叉树。树中每个节点与数组中存放该节点值的那个元素对应。在堆排序算法中，我们使用最大堆。

##堆节点的访问

通常堆是通过一维数组来实现的。之所以用数组，是因为二叉堆是一棵完全二叉树，是有序的。  
- 在数组起始为 0 的情形中，如果 i 为当前节点的索引，则有  
1. 父节点在位置 floor((i-1)/2)；  
2. 左子节点在位置 (2*i+1)；  
3. 右子节点在位置 (2*i+2)；  

- 如果数组起始为1（不使用0），则有  
1.父节点在位置 floor(i/2)；  
2.左子节点在位置 (2*i)；  
3.右子节点在位置 (2*i+1)；  

##堆的操作

在堆的数据结构中，堆中的最大值总是位于根节点。堆中定义以下几种操作：
•最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点，保持最大堆性质的关键。运行时间为 O(lg n)。
•创建最大堆（Build-Max-Heap）：在无序的输入数组基础上构造出最大堆。运行时间为 O(n)。
•堆排序（HeapSort）：对一个数组进行原地排序，卸载位在第一个数据的根节点，并做最大堆调整的递归运算。运行时间为 O(n*lg n)。
•抽取最大值（Extract-Max）：相当于执行一次最大堆调整，最大值在根处。运行时间为 O(lg n)。

##算法复杂度
•最差时间复杂度 O(n*logn)
•平均时间复杂度 Θ(n*logn)
•最优时间复杂度 O(n*logn)
•最差空间复杂度 O(n)，辅助空间 O(1)

#优先队列 [知识来源](http://www.cnblogs.com/edwinchen/p/4788541.html)

我们经常会碰到下面这种情况，并不需要将所有数据排序，只需要取出数据中最大（或最小）的几个元素，如排行榜。

那么这种情况下就可以使用优先队列，优先队列是一个抽象数据类型，最重要的操作就是删除最大元素和插入元素，插入元素的时候就顺便将该元素排序（其实是堆有序，后面介绍）了。 

二叉堆

> 二叉堆其实是优先队列的一种实现，下面主要讲的是用数组实现二叉堆。

先上一个实例：
如有一个数组A{9,7,8,3,0,6,5,1,2}
总结一些规律：  
1.当一个二叉树的每个结点都大于等于它的两个子节点时，称为堆有序  
2.根节点是堆有序的二叉树中的最大结点  
3.在数组中，位置为K的结点的父节点，位置为K/2，它的两个子节点位置分别为：2K和2K+1（下标从1开始，A[0]不使用）  

下面就引出一个问题，怎样让一个数组变成堆有序呢？ 

首先，需要介绍两个操作：   
1.由下至上的堆有序化（上浮）    
当插入一个结点，或改变一个结点的值时，上浮指的是交换它和它的父节点以达到堆有序 
在上面的堆中，如果我们把0换成10，那么上浮的操作具体为：   
（1）10比它的父节点7大，所以交换   
（2）交换后，10比它的父节点9还要打，交换   
之后得到二叉树:   
代码如下（需要注意，下标是从1开始，A[0]保留不用，以下所有代码相同）： 
```C#
    public void swim(Integer[] a,Integer key) {

        while(key > 1 && a[key/2] < a[key]) {

            change(a,key/2,key);

            key /= 2;

        }

    }
```
 2.  由上至下的堆有序化（下沉）
由上浮可以很容易得出下沉的概念：

当插入一个结点，或改变一个结点的值时，下沉指的是交换它和它的较大子节点以达到堆有序。 

在原来的二叉树中，如果将根节点9换成4，操作如下： 

（1）4与它的最大子节点8交换位置 

（2）4与它的最大子节点6交换位置 
代码如下： 
```C#
    public void sink(Integer[] a,Integer key) {

        Integer max = key*2;
        while(key*2 < a.length - 1) {
            if(a[key*2] < a[key*2 + 1]) {
                max = key*2 + 1;
            } else {
                max = key*2;
            }
            if(a[key] > a[max])
                break;     
            change(a,key,max);
            key = max;
        }
    }
```
那么将一个数组构造成有序堆，相应的也有两种方法：使用上浮以及使用下沉：

> 初始数组：Integer[] a = {null,2,1,5,9,0,6,8,7,3};

- 上浮构造有序堆： 

    从数组左边到右边依次使用上浮，因为根节点A[1]没有父节点，所以从A[2]开始：
```C#
    public void buildBinaryHeapWithSwim(Integer[] a) {

        for(int k=2;k<a.length;k++) {

            swim(a,k);

        }

    }
```
> 结果如下：
	 a: [null ,9 ,7 ,8 ,5 ,0 ,2 ,6 ,1 ,3] 读者有兴趣可以自己画一下二叉树，看是否有序

- 下沉构造有序堆：
```C# 
	  public void buildBinaryHeapWithSink(Integer[] a) {
        for(int k=a.length/2;k>=1;k--) {
            sink(a,k);
        }
    }
```
为什么使用下沉只需要遍历数组左半边呢？
因为对于一个数组，每一个元素都已经是一个子堆的根节点了，sink()对于这些也适用。如果一个结点的两个子节点都已经是有序堆了，那么在该结点上调用sink()，可以让整个数组变成有序堆，这个过程会递归的建立起有序堆的秩序。我们只需要扫描数组中一半的元素，跳过叶子节点。
> a: [null ,9 ,7 ,8 ,3 ,0 ,6 ,5 ,1 ,2]  

可以看到使用下沉和上浮构造出来的有序堆并不相同，那么用哪一个更好呢？
答案是使用下沉构造有序堆更好，构造一个有N个元素的有序堆，只需少于2N次比较以及少于N次交换。 
