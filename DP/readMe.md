##动态规划
###什么是动态规划（DP）？


非常重要！，不要认为概念不重要，理解的深刻，你才知道对于什么样的问题去考虑有没有动态规划的方法，以及如何去使用动态规划。
1）动态规划是运筹学中用于求解决策过程中的最优化数学方法。 当然，我们在这里关注的是作为一种算法设计技术，作为一种使用多阶段决策过程最优的通用方法
它是应用数学中用于解决某类最优化问题的重要工具。
2）如果问题是由交叠的子问题所构成，我们就可以用动态规划技术来解决它，一般来说，这样的子问题出现在对给定问题求解的递推关系中，这个递推关系包含了相
同问题的更小子问题的解。动态规划法建议，与其对交叠子问题一次又一次的求解，不如把每个较小子问题只求解一次并把结果记录在表中（动态规划也是空间换时间
的），这样就可以从表中得到原始问题的解。
关键词：
它往往是解决最优化问题滴
问题可以表现为多阶段决策（去网上查查什么是多阶段决策！）
交叠子问题：什么是交叠子问题，最有子结构性质。
动态规划的思想是什么：记忆，空间换时间，不重复求解，由交叠子问题从较小问题解逐步决策，构造较大问题的解。
-------------------------------------------------------------------------------------------------------------------------------------------------
关于斐波拉切数列可以作为最简单的一个例子来解释动态规划的思想，在前面讲斐波拉切数列时说过了，不再叙述。
一般来说，一个经典的动态规划算法时自底向上的（从较小问题的解，由交叠性质，逐步决策处较大问题的解），它需要解出给定问题的所有较小子问题。动态规划的
一个变种是试图避免对不必要的子问题求解。如果采用自顶向下的递归来解，那么就避免了不必要子问题的求解（相对于动态规划表现出优势），然而递归又会导致对
同一个子问题多次求解（相对于动态规划表现出劣势），所以将递归和动态规划结合起来，就可以设计一种基于记忆功能的从顶向下的动态规划算法，一个动态规划算法的几个关键点：
1）怎么描述问题，要把问题描述为交叠的子问题
2）交叠子问题的初始条件（边界条件）
3）动态规划在形式上往往表现为填矩阵的形式（在后面会看到，有的可以优化空间复杂度，开一个数组即可，优化也是根据递推式的依赖形式的，后面有篇文章详细说明）
4）填矩阵的方式（或者说顺序）表明了什么？--它表明了这个动态规划从小到大产生的过程，专业点的说就是递推式的依赖形式决定了填矩阵的顺序。

动态规划算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度， 因此它比回溯法、暴力法等要快许多。

现在让我们通过一个例子来了解一下DP的基本原理。

首先，我们要找到某个状态的最优解，然后在它的帮助下，找到下一个状态的最优解。

###“状态”代表什么及如何找到它?

“状态"用来描述该问题的子问题的解。

如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如1元换成2元的时候)

首先我们思考一个问题，如何用最少的硬币凑够i元(i<11)？为什么要这么问呢？ 两个原因：
                                        1.当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论
                                        2.这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。
                                        好了，让我们从最小的i开始吧。
                                        **1、** 当i=0，即我们需要多少个硬币来凑够0元。 由于1，3，5都大于0，即没有比0小的币值，因此凑够0元我们最少需要0个硬币。 这时候我们发现用一个标记来表示这句“凑够0元我们最少需要0个硬币。”会比较方便， 如果一直用纯文字来表述，不出一会儿你就会觉得很绕了。那么， 我们用d(i)=j来表示凑够i元最少需要j个硬币。于是我们已经得到了d(0) =0， 表示凑够0元最小需要0个硬币。
                                        2、当i=1时，只有面值为1元的硬币可用， 因此我们拿起一个面值为1的硬币，接下来只需要凑够0元即可，而这个是已经知道答案的， 即d(0)=0。所以，d(1) =d(1-1)+1 =d(0)+1 =0+1 =1。 这个意思是说：d(总面额-拿起的硬币)+1
                                        3、当i=2时， 仍然只有面值为1的硬币可用，于是我拿起一个面值为1的硬币， 接下来我只需要再凑够2-1=1元即可(记得要用最小的硬币数量)，而这个答案也已经知道了。 所以d(2)=d(2-1)+1 =d(1)+1 =1+1 =2。一直到这里，你都可能会觉得，好无聊， 感觉像做小学生的题目似的。因为我们一直都只能操作面值为1的硬币！耐心点， 让我们看看i=3时的情况。
                                        4、当i=3时，我们能用的硬币就有两种了：1元的和3元的( 5元的仍然没用，因为你需要凑的数目是3元！5元太多了亲)。 既然能用的硬币有两种，我就有两种方案。如果我拿了一个1元的硬币，我的目标就变为了： 凑够3-1=2元需要的最少硬币数量。即d(3) =d(3-1)+1 =d(2)+1 =2+1 =3。 这个方案说的是，我拿3个1元的硬币；第二种方案是我拿起一个3元的硬币， 我的目标就变成：凑够3-3=0元需要的最少硬币数量。即d(3) =d(3-3)+1 =d(0)+1 =0+1 =1. 这个方案说的是，我拿1个3元的硬币。好了，这两种方案哪种更优呢？ 记得我们可是要用最少的硬币数量来凑够3元的。所以， 选择d(3)=1，怎么来的呢？具体是这样得到的：d(3) =min{d(3-1)+1, d(3-3)+1}。
                                        OK，码了这么多字讲具体的东西，让我们来点抽象的。从以上的文字中， 我们要抽出动态规划里非常重要的两个概念：状态和状态转移方程。
                                        上文中d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题的"状态"， 这个状态是怎么找出来的呢？我在另一篇文章 动态规划之背包问题(一)中写过： 根据子问题定义状态。你找到子问题，状态也就浮出水面了。 最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够11元最少需要多少个硬币。 那状态转移方程是什么呢？既然我们用d(i)表示状态，那么状态转移方程自然包含d(i)， 上文中包含状态d(i)的方程是：d(3)=min{d(3-1)+1, d(3-3)+1}。没错， 它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，
                                        d(i)=min{ d(i-vj)+1 }，其中i-vj>
    =0，vj表示第j个硬币的面值。
    而vj会根据不同的面值来循序。
>比如，总额是11，面值有1,3,5，程序会得出 d(1)=1、d(3)=1、d(5)=1 那么计算11时，步骤如下  
  1、循环1、3、5  
    2、循环到1时，从11中取出1，那么结果是d(11-1)+1=d(10)+1  
    3、d(10)=d(10-5)+1 = d(5)+1 = 1+1 = 2 ，结果在取出一枚一元硬币时,剩下10元总额，而10元总额需要2枚5元硬币 ，那么总共需要3枚
    4、接着循环到3，需要5枚，比循环到1的多，跳过  
    5、接着循环到5，需要d(11-5)+1 = d(6)+1 = 2+1 = 3，也是需要3枚
